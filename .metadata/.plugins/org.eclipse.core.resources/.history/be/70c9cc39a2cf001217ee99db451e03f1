package edu.brown.cs.ai.behavior.oomdp.optiondiscovery.macros.macrotraining;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import edu.brown.cs.ai.behavior.oomdp.options.MacroAction;
import edu.brown.cs.ai.behavior.oomdp.planning.deterministc.DeterministicPlanner;
import edu.brown.cs.ai.behavior.oomdp.planning.deterministc.SearchNode;
import edu.umbc.cs.maple.behavior.oomdp.planning.StateHashTuple;
import edu.umbc.cs.maple.oomdp.Action;
import edu.umbc.cs.maple.oomdp.GroundedAction;
import edu.umbc.cs.maple.oomdp.State;

public class MacroTrainingPlanner extends DeterministicPlanner {

	protected List <Action>								baseActions;
	protected List<List<MacroAction>>					macroLevels;
	protected int										maxDepth;
	protected Random									rand;
	protected List <MacroAction>						nullMacros;
	protected int										levelDepth;
	
	protected int										numVisted;
	
	@Override
	public void planFromState(State initialState) {
		
		StateHashTuple sih = this.stateHash(initialState);
		
		numVisted = 0;
		
		if(mapToStateIndex.containsKey(sih)){
			return ; //no need to plan since this is already solved
		}
		
		SearchNode sin = new SearchNode(sih);
		
		for(int i = 0; i < macroLevels.size(); i++){
			
			Set <StateHashTuple> statesOnPath = new HashSet<StateHashTuple>();
			
		}

	}
	
	
	protected SearchNode dfs(SearchNode n, int depth, Set<StateHashTuple> statesOnPath, List <MacroAction> macros){
		
		numVisted++;
		
		if(gc.satisfies(n.s.s)){
			//found goal!
			return n;
		}
		
		if(maxDepth != -1 && depth > maxDepth){
			return null; //back track
		}
		
		statesOnPath.add(n.s);
		
		if(macros.size() > 0){
			
			//then perform dfs traversal with macros
			
		}
		else{
			
			//then perform dfs traversal with primitives
			
		}
		
		
		return null;
	}
	
	
	
	
	
	
	
	
	
	
	
	//suffle elements on [s, e)
	protected void shuffleGroundedActions(List <GroundedAction> gas, int s, int e){
		
		int r = e-s;
		
		for(int i = s; i < e; i++){
			GroundedAction ga = gas.get(i);
			int j = rand.nextInt(r) + s;
			gas.set(i, gas.get(j));
			gas.set(j, ga);
		}
		
	}
	
	
	

}
